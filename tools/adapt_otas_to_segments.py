import argparse
import os
import pickle
import json
import cv2
from typing import List, Tuple
from datetime import datetime, timezone

"""
Adapt OTAS detect_bdy outputs (pickle with bdy_idx_list) into LAPS-compatible segments.json

Input (per VIEW):
  --otas-pred points to a directory that contains detect_seg/*.pkl files generated by OTAS
  Each pkl is a dict: { 'bdy_idx_list': List[int], 'error_list': List[float] }
  The filename stem is the OTAS video_id, typically 'P_cam_act' (e.g., D01_D01_sample_2_seg007)

Output structure under --output:
  {output}/{video_stem}/segmented_videos/{video_stem}_segments.json
  The JSON follows LAPS format: { video, segments[{start_sec,end_sec}], fps, processed_at }

Assumptions:
  - Raw videos are available under --raw-dir (default: ./datasets/gt_raw_videos/{VIEW})
  - We convert frame indices to seconds via sec = frame_idx / fps
  - Segments are intervals between consecutive boundaries (including [0, first_bdy) and [last_bdy, video_end])
"""


def to_segments(boundaries: List[int], fps: float, video_frames: int) -> List[Tuple[float, float]]:
    if video_frames <= 0 or fps <= 0:
        return []
    T = video_frames / fps
    bsec = sorted([max(0.0, min(T, bi / fps)) for bi in boundaries])
    # prune too-close duplicates (< 1 frame apart)
    dedup = []
    for t in bsec:
        if not dedup or abs(t - dedup[-1]) > (1.0 / fps):
            dedup.append(t)
    cuts = [0.0] + dedup + [T]
    segs = []
    for i in range(len(cuts) - 1):
        s, e = cuts[i], cuts[i + 1]
        # guard against zero-length
        if e - s > 1e-6:
            segs.append((float(s), float(e)))
    return segs


def parse_video_stem(otas_video_id: str) -> Tuple[str, str, str, str]:
    """Return (p_name, cam_name, act_name, video_stem) for raw video lookup.
    Example: 'D01_D01_sample_2_seg007' -> ('D01','D01','sample_2_seg007','D01_sample_2_seg007')
    """
    parts = otas_video_id.split('_')
    if len(parts) < 3:
        # fallback
        return otas_video_id, otas_video_id, otas_video_id, otas_video_id
    p_name = parts[0]
    cam_name = parts[1]
    act_name = '_'.join(parts[2:])
    stem = f"{p_name}_{act_name}"
    return p_name, cam_name, act_name, stem


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--otas-pred', required=True, help='OTAS outputs root containing detect_seg/*.pkl')
    parser.add_argument('--output', required=True, help='Output root (LAPS-compatible segmentation_outputs/{VIEW}_OTAS)')
    parser.add_argument('--raw-dir', required=True, help='Raw videos dir for this VIEW (e.g., datasets/gt_raw_videos/D01)')
    args = parser.parse_args()

    detect_dir = os.path.join(args.otas_pred, 'detect_seg')
    if not os.path.isdir(detect_dir):
        raise FileNotFoundError(f'detect_seg folder not found under {args.otas_pred}')

    pkl_files = [f for f in os.listdir(detect_dir) if f.endswith('.pkl')]
    if not pkl_files:
        raise FileNotFoundError(f'No .pkl files under {detect_dir}')

    for fn in sorted(pkl_files):
        video_id = os.path.splitext(fn)[0]
        p_name, cam_name, act_name, stem = parse_video_stem(video_id)
        raw_mp4 = os.path.join(args.raw_dir, f'{stem}.mp4')
        raw_avi = os.path.join(args.raw_dir, f'{stem}.avi')
        raw_path = raw_mp4 if os.path.exists(raw_mp4) else (raw_avi if os.path.exists(raw_avi) else None)
        if raw_path is None:
            print(f'[WARN] raw video not found for {video_id}: {raw_mp4} or {raw_avi}; skip')
            continue
        cap = cv2.VideoCapture(raw_path)
        fps = cap.get(cv2.CAP_PROP_FPS) or 0.0
        frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT) or 0)
        cap.release()
        if fps <= 0 or frames <= 0:
            print(f'[WARN] invalid FPS/frames for {raw_path}; skip')
            continue

        with open(os.path.join(detect_dir, fn), 'rb') as f:
            d = pickle.load(f)
        boundaries = list(d.get('bdy_idx_list', []))
        segs = to_segments(boundaries, fps=fps, video_frames=frames)

        out_dir = os.path.join(args.output, stem, 'segmented_videos')
        os.makedirs(out_dir, exist_ok=True)
        out_json = os.path.join(out_dir, f'{stem}_segments.json')
        payload = {
            'video': os.path.basename(raw_path),
            'segments': [ {'start_sec': s, 'end_sec': e, 'label': f'segment_{i+1}'} for i,(s,e) in enumerate(segs) ],
            'video_duration_sec': frames / fps,
            'fps': fps,
            'processed_at': datetime.now(timezone.utc).isoformat(),
            'segmentation_params': {
                'from': 'OTAS',
                'note': 'converted from boundaries by tools/adapt_otas_to_segments.py'
            }
        }
        with open(out_json, 'w') as f:
            json.dump(payload, f, indent=2)
        print(f'[OK] wrote {out_json} (segments={len(segs)})')


if __name__ == '__main__':
    main()

